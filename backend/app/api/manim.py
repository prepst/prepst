from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import Optional
from pathlib import Path
from supabase import Client
from app.services.manim_service import create_manim_service
from app.core.auth import get_current_user, get_authenticated_client

router = APIRouter(prefix="/manim", tags=["manim"])


class ManimGenerateRequest(BaseModel):
    question: str


@router.post("/generate")
async def generate_video(
    request: ManimGenerateRequest,
    user_id: str = Depends(get_current_user),
    db: Client = Depends(get_authenticated_client),
):
    """
    Generate a Manim video from a natural language math question.
    Checks for similar existing videos first to avoid regenerating.

    Args:
        request: Request with natural language question
        user_id: User ID from authentication token
        db: Database client

    Returns:
        Video generation result with video URL and metadata
    """
    try:
        if not request.question or not request.question.strip():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Question is required",
            )

        # Create service with database client
        manim_service = create_manim_service(db)
        
        result = await manim_service.generate_video_from_question(
            request.question.strip(), user_id=user_id
        )

        return result

    except Exception as e:
        print(f"Error in manim generate endpoint: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate video: {str(e)}",
        )


@router.get("/videos")
async def list_user_videos(
    user_id: str = Depends(get_current_user),
    db: Client = Depends(get_authenticated_client),
    limit: int = 50,
):
    """
    List videos generated by the current user.

    Args:
        user_id: User ID from authentication token
        db: Database client
        limit: Maximum number of videos to return

    Returns:
        List of user's videos
    """
    try:
        result = (
            db.table("manim_videos")
            .select("*")
            .eq("user_id", user_id)
            .order("created_at", desc=True)
            .limit(limit)
            .execute()
        )

        return {"videos": result.data or []}

    except Exception as e:
        print(f"Error listing videos: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list videos: {str(e)}",
        )


@router.get("/videos/{filename}")
async def get_video(
    filename: str,
):
    """
    Serve generated Manim video files.
    Public endpoint - no auth required for video playback.

    Args:
        filename: Video filename (e.g., scene_id.mp4)

    Returns:
        Video file
    """
    try:
        # Try multiple possible paths
        output_dir = Path(__file__).parent.parent.parent / "manim_output"
        
        # Path 1: Direct file
        video_path = output_dir / filename
        
        # Path 2: In media/videos structure
        if not video_path.exists():
            scene_id = filename.replace(".mp4", "")
            video_path = (
                output_dir
                / "media"
                / "videos"
                / f"scene_{scene_id}"
                / "480p15"
            )
            # Find any .mp4 file in this directory
            if video_path.exists():
                mp4_files = list(video_path.glob("*.mp4"))
                if mp4_files:
                    video_path = mp4_files[0]

        if not video_path.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Video not found",
            )

        return FileResponse(
            video_path,
            media_type="video/mp4",
            filename=filename,
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error serving video: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to serve video: {str(e)}",
        )

