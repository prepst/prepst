from fastapi import APIRouter, HTTPException, status, Depends, Request
from fastapi.responses import FileResponse, Response
from pydantic import BaseModel
from typing import Optional
from pathlib import Path
import httpx
from supabase import Client
from app.core.auth import get_current_user, get_authenticated_client
from app.config import get_settings

# Conditionally import manim service (only available on Railway)
try:
    from app.services.manim_service import create_manim_service
    MANIM_AVAILABLE = True
except ImportError:
    # Manim not available (Vercel deployment without manim dependencies)
    MANIM_AVAILABLE = False
    create_manim_service = None

router = APIRouter(prefix="/manim", tags=["manim"])
settings = get_settings()


class ManimGenerateRequest(BaseModel):
    question: str


@router.post("/generate")
async def generate_video(
    request: ManimGenerateRequest,
    http_request: Request,
    user_id: str = Depends(get_current_user),
    db: Client = Depends(get_authenticated_client),
):
    """
    Generate a Manim video from a natural language math question.
    Checks for similar existing videos first to avoid regenerating.
    
    If MANIM_SERVICE_URL is set (Vercel), proxies request to Railway.
    Otherwise (Railway), uses local manim service.

    Args:
        request: Request with natural language question
        http_request: HTTP request object for forwarding headers
        user_id: User ID from authentication token
        db: Database client

    Returns:
        Video generation result with video URL and metadata
    """
    try:
        if not request.question or not request.question.strip():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Question is required",
            )

        # If MANIM_SERVICE_URL is set, proxy to Railway
        if settings.manim_service_url and settings.manim_service_url.strip():
            try:
                async with httpx.AsyncClient(timeout=300.0) as client:
                    # Forward authorization header
                    headers = {}
                    auth_header = http_request.headers.get("Authorization")
                    if auth_header:
                        headers["Authorization"] = auth_header
                    
                    # Ensure URL has protocol
                    manim_url = settings.manim_service_url.strip()
                    if not manim_url.startswith(("http://", "https://")):
                        manim_url = f"https://{manim_url}"
                    
                    # Forward request to Railway
                    response = await client.post(
                        f"{manim_url}/api/manim/generate",
                        json={"question": request.question.strip()},
                        headers=headers,
                    )
                    response.raise_for_status()
                    return response.json()
            except httpx.HTTPError as e:
                print(f"Error proxying to Railway: {str(e)}")
                raise HTTPException(
                    status_code=status.HTTP_502_BAD_GATEWAY,
                    detail=f"Failed to connect to manim service: {str(e)}",
                )

        # Use local manim service (Railway deployment)
        if not MANIM_AVAILABLE:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Manim service is not available. Please configure MANIM_SERVICE_URL or deploy to Railway.",
            )
        
        manim_service = create_manim_service(db)
        
        result = await manim_service.generate_video_from_question(
            request.question.strip(), user_id=user_id
        )

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in manim generate endpoint: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate video: {str(e)}",
        )


@router.get("/videos")
async def list_user_videos(
    http_request: Request,
    user_id: str = Depends(get_current_user),
    db: Client = Depends(get_authenticated_client),
    limit: int = 50,
):
    """
    List videos generated by the current user.
    
    If MANIM_SERVICE_URL is set (Vercel), proxies request to Railway.
    Otherwise (Railway), queries local database.

    Args:
        http_request: HTTP request object for forwarding headers
        user_id: User ID from authentication token
        db: Database client
        limit: Maximum number of videos to return

    Returns:
        List of user's videos
    """
    try:
        # If MANIM_SERVICE_URL is set, proxy to Railway
        if settings.manim_service_url and settings.manim_service_url.strip():
            try:
                async with httpx.AsyncClient(timeout=30.0) as client:
                    # Forward authorization header
                    headers = {}
                    auth_header = http_request.headers.get("Authorization")
                    if auth_header:
                        headers["Authorization"] = auth_header
                    
                    # Ensure URL has protocol
                    manim_url = settings.manim_service_url.strip()
                    if not manim_url.startswith(("http://", "https://")):
                        manim_url = f"https://{manim_url}"
                    
                    # Forward request to Railway
                    response = await client.get(
                        f"{manim_url}/api/manim/videos",
                        params={"limit": limit},
                        headers=headers,
                    )
                    response.raise_for_status()
                    return response.json()
            except httpx.HTTPError as e:
                print(f"Error proxying to Railway: {str(e)}")
                raise HTTPException(
                    status_code=status.HTTP_502_BAD_GATEWAY,
                    detail=f"Failed to connect to manim service: {str(e)}",
                )

        # Use local database (Railway deployment)
        if not MANIM_AVAILABLE:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Manim service is not available. Please configure MANIM_SERVICE_URL or deploy to Railway.",
            )
        
        result = (
            db.table("manim_videos")
            .select("*")
            .eq("user_id", user_id)
            .order("created_at", desc=True)
            .limit(limit)
            .execute()
        )

        return {"videos": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing videos: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list videos: {str(e)}",
        )


@router.get("/videos/{filename}")
async def get_video(
    filename: str,
    http_request: Request,
):
    """
    Serve generated Manim video files.
    Public endpoint - no auth required for video playback.
    
    If MANIM_SERVICE_URL is set (Vercel), proxies request to Railway.
    Otherwise (Railway), serves local video files.
    
    Note: Videos are stored in Supabase Storage with organized paths:
    {category_slug}/{topic_slug}/{short_id}.mp4
    Example: algebra/linear-functions/a3f9b2c1.mp4
    
    Videos are typically accessed via Supabase Storage public URLs directly.
    This endpoint is mainly for backward compatibility.

    Args:
        filename: Video filename or path (e.g., "a3f9b2c1.mp4" or "algebra/linear-functions/a3f9b2c1.mp4")
        http_request: HTTP request object for forwarding

    Returns:
        Video file
    """
    try:
        # If MANIM_SERVICE_URL is set, proxy to Railway
        if settings.manim_service_url and settings.manim_service_url.strip():
            try:
                async with httpx.AsyncClient(timeout=60.0, follow_redirects=True) as client:
                    # Ensure URL has protocol
                    manim_url = settings.manim_service_url.strip()
                    if not manim_url.startswith(("http://", "https://")):
                        manim_url = f"https://{manim_url}"
                    
                    # Forward request to Railway
                    response = await client.get(
                        f"{manim_url}/api/manim/videos/{filename}",
                    )
                    response.raise_for_status()
                    
                    # Return the video response
                    return Response(
                        content=response.content,
                        media_type="video/mp4",
                        headers={
                            "Content-Disposition": f'inline; filename="{filename}"',
                            "Cache-Control": "public, max-age=3600",
                        }
                    )
            except httpx.HTTPError as e:
                print(f"Error proxying video to Railway: {str(e)}")
                raise HTTPException(
                    status_code=status.HTTP_502_BAD_GATEWAY,
                    detail=f"Failed to connect to manim service: {str(e)}",
                )

        # Serve local video files (Railway deployment)
        if not MANIM_AVAILABLE:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Manim service is not available. Please configure MANIM_SERVICE_URL or deploy to Railway.",
            )
        
        output_dir = Path(__file__).parent.parent.parent / "manim_output"
        
        # Path 1: Direct file
        video_path = output_dir / filename
        
        # Path 2: In media/videos structure
        if not video_path.exists():
            scene_id = filename.replace(".mp4", "")
            video_path = (
                output_dir
                / "media"
                / "videos"
                / f"scene_{scene_id}"
                / "480p15"
            )
            # Find any .mp4 file in this directory
            if video_path.exists():
                mp4_files = list(video_path.glob("*.mp4"))
                if mp4_files:
                    video_path = mp4_files[0]

        if not video_path.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Video not found",
            )

        return FileResponse(
            video_path,
            media_type="video/mp4",
            filename=filename,
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error serving video: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to serve video: {str(e)}",
        )

